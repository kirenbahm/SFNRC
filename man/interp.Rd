% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/biscInterp.R
\name{interp}
\alias{interp}
\title{Make interpolated maps}
\usage{
interp(
  inputData,
  paramCol = "SALINITY",
  yearCol = "year",
  year = "2016",
  returnRas = FALSE,
  exportRaster = FALSE,
  fileName = "NA.tif",
  mapLayer = SFNRC::bnp,
  exportPlot = FALSE,
  plotName = "NA.png",
  plotWidth = 4,
  plotHeight = 5,
  plotRes = 200,
  plotZLims = NA,
  minDataPoints = 2,
  interpMethod = "ordinary kriging",
  vgModelType = c("Nug", "Exp", "Sph", "Gau", "Exc", "Mat", "Ste", "Cir", "Lin", "Bes",
    "Pen", "Per", "Wav", "Hol", "Log", "Pow", "Spl"),
  excludeOutsidePts = TRUE,
  ...
)
}
\arguments{
\item{inputData}{dataframe with water quality data. Function works best with output of \code{dfe.wq() or dfe.hydro()} using \code{wide = TRUE}.}

\item{paramCol}{character string, name of column containing the relevant water quality data}

\item{yearCol}{character string, name of column indicating relevant temporal divisions}

\item{year}{time period to be used for the plot (subset from \code{yearCol}, above)}

\item{returnRas}{TRUE/FALSE; should a raster layer be returned to the global environment}

\item{exportRaster}{TRUE/FALSE; should a raster layer be saved to disk?}

\item{fileName}{if a raster layer is exported, this argument sets the file address and name}

\item{mapLayer}{Can be any SpatialPolygonDataFrame layer. Default is a polygon layer of Biscayne Bay (included in SNFRC package)}

\item{exportPlot}{TRUE/FALSE; should the displayed plot be saved to disk?}

\item{plotName}{if the plot is exported, this argument sets the file address and name}

\item{plotWidth}{width of the plot}

\item{plotHeight}{height of the plot}

\item{plotRes}{resolution of the plot}

\item{plotZLims}{range for colors plotted in figure. This is useful for standardizing when multiple plots are being produced}

\item{minDataPoints}{minimum number of data points considered necessary for interpolation}

\item{interpMethod}{interpolation method - can be "ordinary kriging" or "nearest neighbor"}

\item{vgModelType}{model type passed to \code{fit.variogram()} to interpolate data. See \code{?fit.variogram} for more details}

\item{excludeOutsidePts}{TRUE/FALSE value indicating whether data points falling outside \code{mapLayer} be excluded. Default is TRUE.}

\item{...}{additional arguments used in vgm(); see \code{?vgm} for details.}
}
\value{
plot, raster layer, and/or raster data
}
\description{
Spatial interpolation of data from points to a user-provided polygon layer.
}
\examples{
 
\dontrun{
fin2 <- reshape2::dcast(finDat[, -c(4, 7)], stn + date + year ~ param, 
        fun.aggregate = mean) # long to wide
agm <- plyr::ddply(fin2[, -c(2)], plyr::.(year, stn), plyr::numcolwise(geoMean))
names(agm) <- gsub(x = names(agm), pattern = " |,", replacement = "")
names(agm) <- gsub(x = names(agm), pattern = "-|[+]", replacement = ".")
agmWithCoords <- plyr::join_all(list(agm, as.data.frame(masterCoords)), by = "stn")
sitesInBay <- agmWithCoords[!is.na(agmWithCoords$long), ]
coordinates(sitesInBay) <- c("long", "lat")
proj4string(sitesInBay) <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")

interp(inputData = sitesInBay,
    paramCol = "SALINITY", year = "2016")
    
    ### store raster layer in working environment
biscRas <- interp(inputData = sitesInBay,
    paramCol = "SALINITY", year = "2016", returnRas = TRUE)
    }


}
