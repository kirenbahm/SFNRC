---
title: 'Water quality in Biscayne Bay: Status and trends'
subtitle: ''
output: 
  pdf_document: 
    latex_engine: pdflatex
vignette: >
  %\VignetteIndexEntry{DataForEver}
  %\VignetteEngine{knitr::knitr}
  %\usepackage[UTF-8]{inputenc}
mainfont: FreeMono
header-includes:
- \usepackage{pdflscape}
- \newcommand{\blandscape}{\begin{landscape}}
- \newcommand{\elandscape}{\end{landscape}}
- \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE, echo=FALSE}
if(!require(knitr)){
  install.packages("knitr", repos='http://cran.us.r-project.org')
}
if(!require(rmarkdown)){
  install.packages("rmarkdown", repos='http://cran.us.r-project.org')
}
if(!require(plyr)){
  install.packages("plyr", repos='http://cran.us.r-project.org')
}
if(!require(reshape2)){
  install.packages("reshape2", repos='http://cran.us.r-project.org')
}
if(!require(ggplot2)){
  install.packages("ggplot2", repos='http://cran.us.r-project.org')
}
if(!require(scales)){
  install.packages("scales", repos='http://cran.us.r-project.org')
}
if(!require(maptools)){ # this package may be unnecessary
  install.packages("scales", repos='http://cran.us.r-project.org')
}
if(!require(rgeos)){
  install.packages("rgeos", repos='http://cran.us.r-project.org')
}
if(!require(deldir)){
  install.packages("deldir", repos='http://cran.us.r-project.org')
}

# then load the package:
library(knitr)
library(rmarkdown)
library(plyr)
library(reshape2)
library(ggplot2)
library(scales)
library(SFNRC)

library(maptools)
library(rgeos)
library(sp)
library(dismo)
library(deldir)
library(gstat)
library(rgdal)
library(raster)

knitr::opts_chunk$set(echo = TRUE, comment=NA)
```

## Summary

Water quality trends in Biscayne Bay were evaluated using data from DataForEver and the Miami-Dade Department of Environmental Resources Management. Spatial and temporal trends were evaluated for subregions of the bay using interpolated raster layers for each water quality parameter. This approach minimizes, but does not eliminate, artifacts introduced by varying sampling locations. The effect of canal inflows on water quality in Biscayne Bay was also evaluated.


\vspace{3mm}\hrule

**Keywords:** Biscayne Bay, water quality


```{r, echo = FALSE, include=FALSE}
# if the NitrogenUptake2016 package isn't installed, use devtools to do so:
# devtools::install_github("troyhill/NitrogenUptake2016", build_vignettes = TRUE)

# set some constants
todaysDate <- substr(as.character(Sys.time()), 1, 10)
pointSize <- 2 # for ggplot graphics
pd <- pd2 <- position_dodge(1.2)
pd3 <- position_dodge(0.8)
grayColor <- 0.55
fig2Col   <- "gray55"


compareParams <- c("AMMONIA-N", "NITRATE+NITRITE-N",
                   "SALINITY", "PH, FIELD", "CHLOROPHYLL-A", "TURBIDITY", "DISSOLVED OXYGEN", 
                   "PHOSPHATE, TOTAL AS P", "PHOSPHATE, ORTHO AS P")

## compiled water quality data - regenerate this.
summary(finDat)  # bay water quality data - merged with latest DERM data
summary(wqDat)   # canal water quality data (DERM data not likely to be relevant)

## hydrology data
summary(hydDat)  # canal inflows


```



## 1. Annual water quality trends in Biscayne Bay


```{r interpolated water quality rasters, echo = FALSE, include=FALSE}

# http://rspatial.org/analysis/rst/4-interpolation.html ------------------
fin2 <- dcast(finDat[, -c(4, 7)], stn + date + year ~ param) # long to wide
fin2 <- seas(fin2, timeCol = "date")
fin2$seas2  <- paste0(fin2$waterYr,"-", fin2$seas)


# Create interpolated maps of annual geometric means ----------------------
### Data are not finalized, so this is just laying out the conceptual approach. Interpolate for the whole bay and then clip for regions.
agm <- plyr::ddply(fin2[, -c(2)], plyr::.(year, stn), plyr::numcolwise(geoMean))
names(agm) <- gsub(x = names(agm), pattern = " |,", replacement = "")
names(agm) <- gsub(x = names(agm), pattern = "-|[+]", replacement = ".")


finDat.coords <- plyr::join_all(list(agm, masterCoords), by = "stn")
finDat.coords <- finDat.coords[!is.na(finDat.coords$long), ]

coordinates(finDat.coords) <- c("long", "lat")
proj4string(finDat.coords) <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")

sitesInBay <- sp::over(finDat.coords, bnp)
sitesInBay <- finDat.coords[complete.cases(sitesInBay), ]



# kriging --------------------------------------------------------------
# biscInterp(inputData = sitesInBay,paramCol = "SALINITY", year = "2016")
    
    ### store raster layer in working environment
# biscRas <- biscInterp(inputData = sitesInBay,
    # paramCol = "SALINITY", year = "2016", returnRas = TRUE)


### 
targParam <- "SALINITY"
targYear  <- "2016"
a <- biscInterp(inputData = sitesInBay, 
           paramCol = targParam, year = targYear, yearCol = "year", returnRas = TRUE)
           
dat.l <- list()
for (j in c(5, 10)) { #4:(length(names(sitesInBay) - 1))) {
  for (i in 1995:2010) { #1:length(unique(sitesInBay$year))) {
    targYear  <- i # unique(sitesInBay$year)[i]
    targParam <- names(sitesInBay)[j] # "SALINITY" 
    targDat   <- sitesInBay
    lims      <- as.numeric(quantile(data.frame(targDat@data[, targParam]), c(0, 1), na.rm = TRUE))
    dat.l[[paste0(targParam, targYear)]] <- biscInterp(inputData = targDat, paramCol = targParam, year = targYear, yearCol = "year", plotZLims = lims, returnRas = TRUE)
    # names(dat.l)[i] <- paste0(targParam, targYear)
  }
}


### summarize
# https://gis.stackexchange.com/questions/270988/raster-data-extract-to-polygon-rcode
# possible approach would be to create a raster stack (https://gis.stackexchange.com/questions/29118/how-to-find-the-average-raster-value-of-an-area-defined-by-a-shapefile-using-r)
# get mean and area <20 psu for bay subregions 
###
test     <- ldply(dat.l, function(x) cellStats(x, "mean"))
test$sd  <- ldply(dat.l, function(x) cellStats(x, "sd"))[, 2]
test$param <- substr(test[, 1], 1, nchar(test[, 1]) - 4)
test$yr  <- substr(test[, 1], nchar(test[, 1]) - 3, nchar(test[, 1]))


### get mean for each region in bnp map
plot(bnp, col = bnp@data$OBJECTID)
pointLabel(coordinates(bnp),labels=bnp$OBJECTID)

# adat    <- extract(dat.l[[1]], bnp, fun = mean, na.rm = TRUE, df = TRUE, sp = TRUE) # to preserve spatial relation
# adat@data

# adat    <- extract(dat.l[[1]], bnp, fun = mean, na.rm = TRUE)
# adat.sd <- extract(dat.l[[1]], bnp, fun = sd, na.rm = TRUE)
# adat.20 <- extract(dat.l[[1]], bnp, fun = ecdf()(3))

# raster::stack
adat <- ldply(dat.l, function(x) t(extract(x, bnp, fun = mean, na.rm = TRUE)))
adat.20 <- ldply(dat.l, function(x) t(extract(x, bnp, fun = function(x,...)ecdf(x)(20), na.rm = TRUE))) # proportion of total area below 20 (for salinity)
adat.sd <- ldply(dat.l, function(x) t(raster::extract(x, bnp, fun = sd, na.rm = TRUE)))
# adat.sd

### to make a wide dataset:
# names(adat)[-1] <- paste0("mean.", bnp@data$OBJECTID)
# names(adat.20)[-1] <- paste0("cellsSub20.", bnp@data$OBJECTID)
# names(adat.sd)[-1] <- paste0("sd.", bnp@data$OBJECTID)
# combd       <- join_all(list(adat, adat.sd, adat.20))

### to make a long dataset with columns: param, year, loc, mean, sd, ecdf20
tail(melt(adat, id.vars = 1, variable.name = "polygon", value.name = "mean"))

combd <- join_all(list(
  melt(adat, id.vars = 1, variable.name = "polygon", value.name = "mean"),
  melt(adat.sd, id.vars = 1, variable.name = "polygon", value.name = "sd"),
  melt(adat.20, id.vars = 1, variable.name = "polygon", value.name = "cellsSub20")
))





combd$param <- substr(combd[, 1], 1, nchar(combd[, 1]) - 4)
combd$yr    <- substr(combd[, 1], nchar(combd[, 1]) - 3, nchar(combd[, 1]))

ggplot(combd, aes())

### I can't figure out how to generate multiple columns at the same time, avoiding the need to join_all. e.g., this doesn't work:
# test <- ldply(sal.list, summarise,
#               # name = names(x),
#               mean = function(x) cellStats(x, "mean"),
#               area_sub20 = function(x) cellStats(x, "ecdf(x)(20)"))

# 
# ### now repeat for all parameters
# wq.list <- list()
# for (j in 4:(length(names(sitesInBay)) - 1)) {
#   for (i in 1:length(unique(sitesInBay$year))) {
#     targYear  <- unique(sitesInBay$year)[i]
#     targParam <- names(sitesInBay)[j]
#     targDat   <- sitesInBay
#     lims      <- as.numeric(quantile(data.frame(targDat@data[, targParam]), c(0, 1), na.rm = TRUE))
#     wq.list[i] <- biscInterp(inputData = targDat, paramCol = targParam, year = targYear, yearCol = "year", plotZLims = lims,returnRas = TRUE)
#     names(wq.list)[i] <- paste0(targParam, targYear)
#   }
# }
# 
# test <- ldply(wq.list, function(x) cellStats(x, "mean"))

```



## 2. Effect of canal inflows



**2.1.	 text**

mass = (height$\cdot$a + b)^1/$\lambda$^ 


```{r allometry, include=FALSE, echo=FALSE}


```


```{r Figure 1 (Data In Brief), fig.width = 6, fig.height = 4, message = FALSE, include=FALSE, echo=FALSE}

```



