---
title: 'Exploring DataForEver data using the SFNRC R package'
subtitle: ''
output: 
  pdf_document: 
latex_engine: pdflatex
vignette: >
  %\VignetteIndexEntry{DataForEver}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[UTF-8]{inputenc}
mainfont: FreeMono
header-includes:
- \usepackage{pdflscape}
- \newcommand{\blandscape}{\begin{landscape}}
- \newcommand{\elandscape}{\end{landscape}}
- \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE, echo=FALSE}
if(!require(knitr)){
  install.packages("knitr", repos='http://cran.us.r-project.org')
}
if(!require(rmarkdown)){
  install.packages("rmarkdown", repos='http://cran.us.r-project.org')
}
if(!require(plyr)){
  install.packages("plyr", repos='http://cran.us.r-project.org')
}
if(!require(reshape2)){
  install.packages("reshape2", repos='http://cran.us.r-project.org')
}
if(!require(ggplot2)){
  install.packages("ggplot2", repos='http://cran.us.r-project.org')
}
if(!require(scales)){
  install.packages("scales", repos='http://cran.us.r-project.org')
}
if(!require(gridExtra)){
  install.packages("gridExtra", repos='http://cran.us.r-project.org')
}
if(!require(sp)){
  install.packages("sp", repos='http://cran.us.r-project.org')
}

# then load the package:
library(knitr)
library(rmarkdown)
library(sp)
library(plyr)
library(reshape2)
library(ggplot2)
library(scales)
library(gridExtra)
library(SFNRC)

knitr::opts_chunk$set(echo = TRUE, comment=NA)
```

\vspace{12pt}
\vspace{12pt}

## 1. Introduction

The `SFNRC` R package provides a simple, streamlined means of interacting with the DataForEver hydrology and water quality databases from within an analytical programming environment (RStudio). Additional tools are also included in the package, including:

- APIs for the South Florida Water Management District's DBHYDRO database

- A function to process data collected by the Miami-Dade Department of Environmental and Resources Management in preparation for merging it with DataForEver data

- A responsive tool for spatial interpolation of data

- Utility functions to calculate annual geometric means, label seasons and water years, and similar rudimentary tasks.

This vignette demonstrates some of the functionality of the `SFNRC` R package. 


Before demonstrating the package's capabilities, it is important to highlight some limitations of the `SFNRC` R package. The DataForEver APIs can only be used on Linux machines connected to the SFNRC's internal network. When DataForEver's data are opened up to the general public, the capabilities in this R package will be adapted to provide broader access to these world-class databases. Another important aspect to draw attention to is the construction and use of BASH shell scripts by the DataForEver API functions. This dependence on BASH is the reason the APIs only work on Linux operating systems.


\vspace{12pt}


\vspace{3mm}\hrule
\vspace{12pt}



\vspace{12pt}
\vspace{12pt}

```{r, echo = FALSE, include=FALSE}
# if the NitrogenUptake2016 package isn't installed, use devtools to do so:
# devtools::install_github("troyhill/NitrogenUptake2016", build_vignettes = TRUE)

# set some constants
todaysDate <- substr(as.character(Sys.time()), 1, 10)
core.area <- pot.m2 <- 0.00801185 # mesocosm surface area (m2)
top.vol   <- core.area * 0.05 * 1e6 # cm3 in core: top 5 cm only
pointSize <- 2 # for ggplot graphics
pd <- pd2 <- position_dodge(1.2)
pd3 <- position_dodge(0.8)
grayColor <- 0.55
fig2Col   <- "gray55"


```

\vspace{12pt}
\vspace{12pt}


**2. Automated access to DataForEver**
\vspace{12pt}

Users can search for stations in the DataForEver databases:

\vspace{12pt}

```{r stn_query, include=TRUE, echo=TRUE, eval=FALSE}
getStn(query = "s33")
```

\vspace{12pt}

Users can also query the parameters available for each station in the DataForEver hydrology database, using parameter and/or station names as constraints:


\vspace{12pt}

```{r stn_query2, include=TRUE, echo=TRUE, eval=FALSE}
getDataTypes(parameter = "salinity")

getDataTypes(stn = "S333")

## to search for exact matches, set `fixed = TRUE`
getDataTypes(stn = "S333", fixed = TRUE)

```



\vspace{12pt}
\vspace{12pt}

**3. Downloading DataForEver data**
\vspace{12pt}

Using `SFNRC` to download DataForEver data is very straightforward. The water quality database is accessed using the function `getWQ()`:

\vspace{12pt}


```{r wq, include=TRUE, echo=TRUE, results = "hide"}
# identify desired stations and water quality parameters
stations   <- c("S333", "S12A")
wqParams   <- c("PHOSPH|NITROGEN|AMMONI|SUSPENDED|TURBIDITY")

```

```{r wq2, include=TRUE, echo=TRUE, results = "hide", eval=FALSE}
dat <- getWQ(stns = stations, target_analytes = wqParams)
head(dat)

```

\vspace{12pt}

The `SFNRC` R package can also be used to download data from the DataForEver hydrology database using a function called `getHydro()`. The `data_shape` argument reshapes data from long to wide form to facilitate a broad range of end-user analyses.

\vspace{12pt}

```{r hydro_get_data, include=TRUE, echo=TRUE}
hydroParams <- c("flow", "head_water")

```

```{r hydro_get_data21, include=TRUE, echo=TRUE, eval=FALSE}
### by default, data are in "long" format, with one row 
### for every date-station-parameter combination
hyd.long  <- getHydro(stns = stations, parameter_list = hydroParams)

### but data can also be retrieved in "wide" (one row per date-station) or 
### "really_wide" (one row per date) forms, enabling more rapid 
### comparison between stations and/or parameters
hyd.wide  <- getHydro(stns = stations, parameter_list = hydroParams, data_shape = "wide")
hyd.vwide <- getHydro(stns = stations, parameter_list = hydroParams, data_shape = "really_wide")

```


```{r hydro_show, include=TRUE, echo=TRUE, eval=FALSE}
head(hyd.long) # one row for every date-station-parameter combination
head(hyd.wide) # one row for every date-station combination
head(hyd.vwide) # one row for every date

```



\vspace{12pt}
\vspace{12pt}

Merging water quality and hydrology data is a routine task that is automated by `SFNRC`. Instead of navigating the two databases and then figuring out how to merge the two datasets, water quality data can be downloaded at the same time as flow/hydrology data by setting `getWaterQuality = TRUE` in a call to `getHydro()`. To reduce the number of columns in the returned dataset, it is recommended that water quality parameters be specified manually in this workflow, because the returned dataset will have two columns per parameter (returning the MDL and the value).

\vspace{12pt}

```{r hydro_get_data2, include=TRUE, message = FALSE, warning = FALSE, eval = FALSE}

### simultaneously download hydrology and water quality data:
hyd.wq <- getHydro(stns = stations, 
                   parameter_list = hydroParams, # hydrology database parameters
                   getWaterQuality = TRUE, 
                   target_analytes = wqParams) # water quality database parameters

```

```{r internalWorkaround, include=TRUE, message = FALSE, warning = FALSE, eval = TRUE, echo = FALSE}
### simultaneously download hydrology and water quality data:
wq.prep  <- wqDat[(wqDat$stn %in% stations) & grepl(x = wqDat$param, pattern = wqParams), ]
wq.prep2 <- stats::reshape(wq.prep, idvar = c("stn", "date", "year", "mo", "day", "time", "datetime"), timevar = "param", direction = "wide")
names(wq.prep2) <- gsub(x = names(wq.prep2), pattern = "value.| |,", replacement = "")
wqDatForMerge <- wq.prep2[, c(grep(x = names(wq.prep2), pattern = "matrix", value = TRUE, invert = TRUE))] # exclude matrix columns

hyd.prep <- hydDat[(hydDat$stn %in% stations), ]


hyd.wq <- plyr::join_all(list(hyd.prep, wqDatForMerge), by = c("stn", "date"))

```

\vspace{12pt}

At this point the data can be plotted or analyzed. For example, simple time series plots:

\vspace{12pt}
```{r hydro_show_merged, include=TRUE, echo=FALSE, warning=FALSE, message=FALSE, fig.width = 3, fig.height = 3}
ggplot(data = data.frame(hyd.wq), aes(y = PHOSPHATETOTALASP, x = datetime, shape = stn)) + 
  theme_classic() + geom_point(show.legend = FALSE) + geom_smooth() + facet_grid(stn ~ .) + ylim(0, 0.1) + ylab("Total P (mg/L)") + xlab("")

```

\vspace{12pt}

Relationships between hydrologic and water quality parameters can be explored: 

\vspace{12pt}

```{r plot_wqFlow, echo=FALSE, warning=FALSE, message=FALSE, fig.width = 3, fig.height = 4}
invisible(CQ <- ggplot(data = data.frame(hyd.wq[(hyd.wq$flow > 0) & !is.na(hyd.wq$flow), ]), aes(y = log(PHOSPHATETOTALASP), x = log(flow), shape = stn)) + 
  theme_classic() + geom_point(show.legend = FALSE) + geom_smooth(method = "lm") + facet_grid(stn ~ .) + ylab("log(TP) (mg/L)") + xlab("log(discharge) (cfs)"))

invisible(C_HW <- ggplot(data = data.frame(hyd.wq), aes(y = PHOSPHATETOTALASP, x = head_water, shape = stn)) + 
  theme_classic() + geom_point(show.legend = FALSE) + geom_smooth() + facet_grid(stn ~ .) + ylim(0, 0.1) + ylab("log(TP) (mg/L)") + xlab("Head water stage (feet NGVD29)"))

invisible(grid.arrange(CQ, C_HW, nrow = 2))

```

\vspace{12pt}
\vspace{12pt}


And relationships between water quality parameters can be evaluated:

\vspace{12pt}

```{r plot_wq_bivariate, echo=FALSE, warning=FALSE, message=FALSE, fig.width = 6, fig.height = 4}
TP.NTU <- ggplot(data = data.frame(hyd.wq), aes(y = PHOSPHATETOTALASP, x = TURBIDITY, shape = stn)) + 
  theme_classic() + geom_point(show.legend = FALSE) + geom_smooth(method = "lm") + facet_grid(stn ~ .) + ylab("TP (mg/L)") + xlab("Turbidity (NTU)") + ylim(0, 0.1)

TN.TP <- ggplot(data = data.frame(hyd.wq), aes(y = PHOSPHATETOTALASP, x = TOTALNITROGEN, shape = stn))  + theme(legend.position="none") + 
  theme_classic() + geom_point(show.legend = FALSE) + geom_smooth(method = "lm") + facet_grid(stn ~ .) + ylab("TP (mg/L)") + xlab("TN (mg/L)") + ylim(0, 0.1) + xlim(0, 3)

grid.arrange(TP.NTU, TN.TP, ncol = 2)

```




\vspace{12pt}
\vspace{12pt}


**4. Spatial interpolation wrapper**

\vspace{12pt}

Spatial interpolation of data is streamlined by the `interp()` function. The function takes a user-specified SpatialPolygonDataframe and interpolates point data. The interpolation method applied to the data can be `ordinary kriging` or `nearest neighbor`. Ordinary kriging estimates data using a variogram model of similarity as a function of distance. By default, a broad range of models are attempted and the best-fitting model is used to produce the output. If `ordinary kriging` is selected but the variogram does not converge (typically indicative of substantial variation over small distances), the `nearest neighbor` approach will instead be used. 

Nearest neighbor interpolation generates Voronoi polygons for the sampling locations and applies the value from each sampling point uniformly within its respective polygon.

\vspace{12pt}

An example of a complete workflow is below. Stations in Biscayne Bay are selected programatically, data undergo some initial processing and an interpolated map of salinity is produced.

\vspace{12pt}


```{r interp_prep1, include=TRUE, echo=TRUE, eval=FALSE}
# find stations in Biscayne Bay
bsc.stns <- getDataTypes(stn = "BISC|BB")
stns     <- as.character(unique(bsc.stns[bsc.stns$parameter %in% "salinity", "stn"]))

# get data
paramsToGet <- c("salinity")
bsc         <- getHydro(stns = stns, parameter_list = paramsToGet)

```


```{r interp_prep2, fig.width = 6, fig.height = 4, message = FALSE, include=FALSE, echo=FALSE}
bsc <- reshape2::dcast(finDat[, -c(4, 7)], stn + date + year ~ param, fun.aggregate = mean) 

```


```{r interp_prep3, message = FALSE, include=TRUE, echo=TRUE, warning = FALSE, fig.width = 4, fig.height = 5}

### assign wet/dry seasons
bsc        <- seas(bsc, wetSeas = c("May", "Sep"), waterYearBegin = "Oct", timeCol = "date")
bsc$seas2  <- paste0(bsc$waterYr,"-", bsc$seas)

### calculate annual geometric means
agm        <- ddply(bsc, plyr::.(stn, seas2), plyr::numcolwise(geoMean))

### add coordinates to make point data spatial
names(agm) <- gsub(x = names(agm), pattern = " |,", replacement = "")
names(agm) <- gsub(x = names(agm), pattern = "-|[+]", replacement = ".")
finDat.coords <- join_all(list(agm, as.data.frame(masterCoords)), by = "stn")
finDat.coords <- finDat.coords[!is.na(finDat.coords$long), ]
coordinates(finDat.coords) <- c("long", "lat")
proj4string(finDat.coords) <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")

sitesInBay <- over(finDat.coords, bnpMod)
sitesInBay <- finDat.coords[complete.cases(sitesInBay), ]


# interpolate! 
interp(inputData = sitesInBay, mapLayer = bnpMod,
       paramCol = "SALINITY", year = "2016-dry", yearCol = "seas2", 
       interpMethod = "ordinary kriging")
```



