---
title: 'Exploring DataForEver data using the SFNRC R package'
subtitle: ''
output: 
  pdf_document: 
latex_engine: pdflatex
vignette: >
  %\VignetteIndexEntry{DataForEver}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[UTF-8]{inputenc}
mainfont: FreeMono
header-includes:
- \usepackage{pdflscape}
- \newcommand{\blandscape}{\begin{landscape}}
- \newcommand{\elandscape}{\end{landscape}}
- \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE, echo=FALSE}
pkgs.used <- c("devtools", "knitr", "rmarkdown", "rgdal", "sp", "deldir", "plyr", "reshape2", "ggplot2", "scales", "gridExtra")
pkgs.to.install <- pkgs.used[!pkgs.used %in% installed.packages()]
if (length(pkgs.to.install) > 0) {
  install.packages(pkgs.to.install)
}
if (!"SFNRC" %in% installed.packages()) {
  devtools::install_github("troyhill/SFNRC")
}

# then load the package:
library(knitr)
library(rmarkdown)
library(rgdal)
library(sp)
library(deldir)
library(plyr)
library(reshape2)
library(ggplot2)
library(scales)
library(gridExtra)
library(SFNRC)

knitr::opts_chunk$set(echo = TRUE, comment=NA)
```

\vspace{12pt}
\vspace{12pt}

## 1. Introduction

The `SFNRC` R package provides a simple, streamlined means of interacting with the DataForEver hydrology and water quality databases from within an analytical programming environment (RStudio). Additional tools are also included in the package, including:

- APIs for the South Florida Water Management District's DBHYDRO database

- A function to process data collected by the Miami-Dade Department of Environmental and Resources Management in preparation for merging it with DataForEver data

- A responsive tool for spatial interpolation of data

- Utility functions to calculate annual geometric means, label seasons and water years, and similar rudimentary tasks.

This vignette demonstrates the DataForEver functions in the `SFNRC` R package. DataForEver comprises internal databases of the South Florida Natural Resources Center, and unfortunately can only be used when directly connected to the SFNRC's internal servers. These elements of the `SFNRC` R package are not presently available to non-NPS users.


\vspace{12pt}


\vspace{3mm}\hrule
\vspace{12pt}



\vspace{12pt}
\vspace{12pt}

```{r, echo = FALSE, include=FALSE}
# set some constants
todaysDate <- substr(as.character(Sys.time()), 1, 10)
core.area <- pot.m2 <- 0.00801185 # mesocosm surface area (m2)
top.vol   <- core.area * 0.05 * 1e6 # cm3 in core: top 5 cm only
pointSize <- 2 # for ggplot graphics
pd <- pd2 <- position_dodge(1.2)
pd3 <- position_dodge(0.8)
grayColor <- 0.55
fig2Col   <- "gray55"


```

\vspace{12pt}
\vspace{12pt}


## 2. Automated access to DataForEver
\vspace{12pt}

Users can search for stations in the DataForEver water quality or hydrology databases. The optional `pattern` argument can be used to narrow the scope of the output.

\vspace{12pt}

```{r stn_query, include=TRUE, echo=TRUE, eval=FALSE}
getStn_DFE(dbname = "waterquality") # all WQ stations
getStn_DFE(pattern = "S333", dbname = "waterquality") # stations matching some string 
getStn_DFE(pattern = "S333", dbname = "hydrology")
```

\vspace{12pt}

Users can also query the parameters available from the hydrology or water quality databases. Queries of the water quality database can provide more concise, station-level lists of available parameters. If stations are used in the query, the output reports the number of observations for each parameter.


\vspace{12pt}

```{r stn_query2, include=TRUE, echo=TRUE, eval=FALSE}
### all parameters in water quality database
getParams_DFE(dbname = "waterquality")
getParams_DFE(dbname = "hydrology")
### parameters available at specific stations (note syntax)
getParams_DFE(stn = "S333|S18C", dbname = "waterquality")

```



\vspace{12pt}
\vspace{12pt}

## 3. Accessing DataForEver data
\vspace{12pt}

Using `SFNRC` to access DataForEver data is very straightforward. The water quality database and hydrology databases are both accessed using the function `getDFE()`:

\vspace{12pt}


```{r wq, include=TRUE, echo=TRUE, results = "hide"}
# identify desired stations and water quality parameters
stations   <- c("S333", "S12A") # this notation is also fine: "S333|S12A"
wqParams   <- c("PHOSPH|NITROGEN|AMMONI|SUSPENDED|TURBIDITY")
hydroParams <- c("flow|head_water")

```

```{r wq2, include=TRUE, echo=TRUE, results = "hide", eval=FALSE}
flowDat <- getDFE(stn = stations, dbname = "hydrology", params = hydroParams,
            startDate = "2018-01-01")
 
wqDat <- getDFE(stn = stations, dbname = "waterquality", params = wqParams,
             startDate = "2018-01-01")
unique(wqDat$station)

```

\vspace{12pt}

The `data_shape` argument reshapes data from long to wide form to facilitate a broad range of analyses.

\vspace{12pt}

```{r hydro_get_data21, include=TRUE, echo=TRUE, eval=FALSE}
### by default, data are in "long" format, with one row 
### for every date-station-parameter combination
hyd.long  <- getDFE(stn = stations, params = hydroParams, startDate = "2018-01-01")

### but data can also be retrieved in "wide" (one row per date-station) or 
### "really_wide" (one row per date) forms, enabling more rapid 
### comparison between stations and/or parameters
hyd.wide  <- getDFE(stn = stations, params = hydroParams, startDate = "2018-01-01",
                      data_shape = "wide")
hyd.vwide <- getDFE(stn = stations, params = hydroParams, startDate = "2018-01-01",
                      data_shape = "really_wide")

```


```{r hydro_show, include=TRUE, echo=TRUE, eval=FALSE}
head(hyd.long) # one row for every date-station-parameter combination
head(hyd.wide) # one row for every date-station combination
head(hyd.vwide) # one row for every date

```



\vspace{12pt}
\vspace{12pt}

Merging water quality and hydrology data is a routine task that is automated by `SFNRC`. Instead of navigating the two databases and then figuring out how to merge the two datasets, water quality data can be downloaded at the same time as flow/hydrology data by setting `addWaterQuality = TRUE` in a call to `getDFE(dbname = 'hydrology')`. To reduce the number of columns in the returned dataset, it is recommended that water quality parameters be specified manually in this workflow, because the returned dataset will have two columns per parameter (returning the MDL and the value).

\vspace{12pt}

```{r hydro_get_data2, include=TRUE, message = FALSE, warning = FALSE, eval = FALSE}

### simultaneously download hydrology and water quality data:
hyd.wq <- getDFE(stn = stations, 
                   params = hydroParams, # hydrology database parameters
                   startDate = "2018-01-01",
                   addWaterQuality = TRUE, 
                   addWaterQualityParams = wqParams) # water quality database parameters

```

```{r internalWorkaround, include=TRUE, message = FALSE, warning = FALSE, eval = TRUE, echo = FALSE}
### simultaneously download hydrology and water quality data:
dd.wq <- plyr::ddply(wqDat[(wqDat$station %in% stations) & grepl(x = wqDat$param, pattern = wqParams), names(wqDat) %in% c("station", "date", "parameter", "value")], .(station, date, parameter),
                         summarise,
                         value = mean(value, na.rm = TRUE))
wq.temp <- stats::reshape(dd.wq, 
                              idvar = c("station", "date"), timevar = "parameter", 
                              direction = "wide")
    names(wq.temp) <- gsub(x = names(wq.temp), pattern = "value.| |,", 
                           replacement = "")

hyd.wq <- plyr::join_all(list(hydDat[hydDat$station %in% stations, ], wq.temp), 
                              by = c("station", "date"))
  
```

\vspace{12pt}

At this point the data can be plotted or analyzed. For example, simple time series plots:

\vspace{12pt}
```{r hydro_show_merged, include=TRUE, echo=FALSE, warning=FALSE, message=FALSE, fig.width = 3, fig.height = 3}
ggplot(data = data.frame(hyd.wq), aes(y = PHOSPHATETOTALASP, x = date, shape = station)) + 
  theme_classic() + geom_point(show.legend = FALSE) + geom_smooth() + facet_grid(station ~ .) + ylim(0, 0.1) + ylab("Total P (mg/L)") + xlab("")

```

\vspace{12pt}

Relationships between hydrologic and water quality parameters can be explored: 

\vspace{12pt}

```{r plot_wqFlow, echo=FALSE, warning=FALSE, message=FALSE, fig.width = 3, fig.height = 4}
invisible(CQ <- ggplot(data = data.frame(hyd.wq[(hyd.wq$flow > 0) & !is.na(hyd.wq$flow), ]), aes(y = log(PHOSPHATETOTALASP), x = log(flow), shape = station)) + 
  theme_classic() + geom_point(show.legend = FALSE) + geom_smooth(method = "lm") + facet_grid(station ~ .) + ylab("log(TP) (mg/L)") + xlab("log(discharge) (cfs)"))

invisible(C_HW <- ggplot(data = data.frame(hyd.wq), aes(y = PHOSPHATETOTALASP, x = head_water, shape = station)) + 
  theme_classic() + geom_point(show.legend = FALSE) + geom_smooth() + facet_grid(station ~ .) + ylim(0, 0.1) + ylab("log(TP) (mg/L)") + xlab("Head water stage (feet NGVD29)"))

invisible(grid.arrange(CQ, C_HW, nrow = 2))

```

\vspace{12pt}
\vspace{12pt}


And relationships between water quality parameters can be evaluated:

\vspace{12pt}

```{r plot_wq_bivariate, echo=FALSE, warning=FALSE, message=FALSE, fig.width = 6, fig.height = 4}
TP.NTU <- ggplot(data = data.frame(hyd.wq), aes(y = PHOSPHATETOTALASP, x = TURBIDITY, shape = station)) + 
  theme_classic() + geom_point(show.legend = FALSE) + geom_smooth(method = "lm") + facet_grid(station ~ .) + ylab("TP (mg/L)") + xlab("Turbidity (NTU)") + ylim(0, 0.1)

TN.TP <- ggplot(data = data.frame(hyd.wq), aes(y = PHOSPHATETOTALASP, x = TOTALNITROGEN, shape = station))  + theme(legend.position="none") + 
  theme_classic() + geom_point(show.legend = FALSE) + geom_smooth(method = "lm") + facet_grid(station ~ .) + ylab("TP (mg/L)") + xlab("TN (mg/L)") + ylim(0, 0.1) + xlim(0, 3)

grid.arrange(TP.NTU, TN.TP, ncol = 2)

```




\vspace{12pt}
\vspace{12pt}

### 20201110: updated up to this point

## 4. Spatial interpolation wrapper

\vspace{12pt}

Spatial interpolation of data is streamlined by the `interp()` function. The function takes a user-specified SpatialPolygonDataframe and interpolates point data. The interpolation method applied to the data can be `ordinary kriging` or `nearest neighbor`. Ordinary kriging estimates data using a variogram model of similarity as a function of distance. By default, a broad range of models are attempted and the best-fitting model is used to produce the output. If `ordinary kriging` is selected but the variogram does not converge (typically indicative of substantial variation over small distances), the `nearest neighbor` approach will instead be used. 

Nearest neighbor interpolation generates Voronoi polygons for the sampling locations and applies the value from each sampling point uniformly within its respective polygon.

\vspace{12pt}

An example of a complete workflow is below. Stations in Biscayne Bay are selected programatically, data undergo some initial processing and an interpolated map of salinity is produced.

\vspace{12pt}


```{r interp_prep1, include=TRUE, echo=TRUE, eval=FALSE}
# find stations in Biscayne Bay
bsc.stns <- getDataTypes(stn = "BISC|BB")
stns     <- as.character(unique(bsc.stns[bsc.stns$parameter %in% "salinity", "stn"]))

# get data
paramsToGet   <- c("salinity")
bsc           <- getHydro(stns = stns, parameter_list = paramsToGet)
names(bsc)[4] <- "SALINITY"
```


```{r interp_prep2, fig.width = 6, fig.height = 4, message = FALSE, include=FALSE, echo=FALSE}
bsc <- reshape2::dcast(finDat[, -c(4, 7)], stn + date + year ~ param, fun.aggregate = mean) 

```


```{r interp_prep3, message = FALSE, include=TRUE, echo=TRUE, warning = FALSE, fig.width = 3.5, fig.height = 3.5}

### assign wet/dry seasons
bsc        <- seas(bsc, wetSeas = c("May", "Sep"), waterYearBegin = "Oct", timeCol = "date")
bsc$seas2  <- paste0(bsc$waterYr,"-", bsc$seas)

### calculate annual geometric means
agm        <- ddply(bsc, .(stn, seas2), numcolwise(geoMean))

### add coordinates to make point data spatial
names(agm)    <- gsub(x = names(agm), pattern = " |,", replacement = "")
names(agm)    <- gsub(x = names(agm), pattern = "-|[+]", replacement = ".")
agmWithCoords <- join_all(list(agm, as.data.frame(masterCoords)), by = "stn")
sitesInBay    <- agmWithCoords[!is.na(agmWithCoords$long), ]
coordinates(sitesInBay) <- c("long", "lat")
proj4string(sitesInBay) <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")


# interpolate! 
interp(inputData = sitesInBay, mapLayer = bnpMod,
       paramCol = "SALINITY", year = "2016-dry", yearCol = "seas2",
       interpMethod = "nearest neighbor")
```



\vspace{12pt}



## 4. Integration with USGS-R/EGRET weighted regression tools

The function `converToEgret` reformats DataForEver data to enable analysis with a suite of excellent trend analysis tools developed by USGS. The object created by running `converToEgret` can be used directly as an input to EGRET functions. 

See https://github.com/USGS-R/EGRET for more information on EGRET.


```{r convertToEgret, message = FALSE, eval=FALSE, echo=FALSE, warning = FALSE, fig.width = 3.5, fig.height = 3.5}

### prep data for EGRET
targStn <- "S333"
targAnalyte <- "PHOSPHATE, TOTAL AS P"

eList <- convertToEgret(stn = targStn, target_analyte = targAnalyte, 
                        wq_data = wqDat, flow_data = hydDat)

### run a model - this takes a couple minutes
eList <- modelEstimation(eList)

```

